<div class="notebook">

<div class="nb-cell markdown" name="md1">
## Bonus Assignment 2(Worth 2.5 Marks)

### Rules

Solve all the questions. Each question is worth the number of marks indicated next to it. You must fully understand the code you've written and be able to demonstrate so in a discussion. Failure to demonstrate that you understand the code = 0 for all your Bonus(i.e: You get no bonus in the course at all even if you delivered everything else without copying.)
</div>

<div class="nb-cell markdown" name="md2">
### Question 1(1 mark)


Consider the following puzzle: There are five blocks numbered from 1 to 5. The blocks are
stacked on top of each other in the following sequence from bottom to top: 4, 1, 2, 5, 3. You
are allowed to reverse the order of any number of blocks from the top of the stack, for
example from the initial state you can obtain the state 4, 1, 3, 5, 2 by reversing the order of
the three top most blocks. The goal is to arrange the blocks according to their numbers with
the biggest at the bottom (i.e., 5, 4, 3, 2, 1).
</div>

<div class="nb-cell program" name="p1">
% Question 1.
% Code: 1301231
% Name: Mohamed Hesham Mostafa
% 
% TODO: Write Your Full Prolog Solution Here.
% Your code should define a predicate solve/0
% when solve is called, it should output the sequence of states.

initial_state([4, 1, 2, 5, 3]).
goal_state([5, 4, 3, 2, 1]).


flip([H1, H2, H3, H4, H5] , [H2, H1, H3, H4, H5]).
flip([H1, H2, H3, H4, H5] , [H3, H2, H1, H4, H5]).
flip([H1, H2, H3, H4, H5] , [H4, H3, H2, H1, H5]).
flip([H1, H2, H3, H4, H5] , [H5, H4, H3, H2, H1]).

next(S1, S2):- flip(S1, S2).

solve(S, soln):- solve(S, [], soln).
solve(S, _, [S]):- goal_state(S).
solve(S, P, [S|T]):- next(S, S1),
                     not(member(S1, P)),
                     solve(S1, [S|P],T).
</div>

<div class="nb-cell query" name="q1">
initial_state(IS), solve(IS,[],Path)
</div>

<div class="nb-cell markdown" name="md3">
### Question 2(1.5 mark)


Consider a standard chessboard and a Knight. How can the Knight pass through all squares on the chessboard such that it passes by each square *exactly* once?
</div>

<div class="nb-cell program" name="p2">
% Question 2.
% Code: 1301231
% Name: Mohamed Hesham Mostafa
% 
% TODO: Write Your Full Prolog Solution Here.
% Your code should define a predicate `solve/0`
% when solve is called, it should output the sequence of positions the Knight will be at such that it passes by all squares exactly once.

% % all possible moves
knight_moves(X, Y, NewX, NewY) :-
    ( NewX is X - 1, NewY is Y - 2 
    ; NewX is X - 1, NewY is Y + 2 
    ; NewX is X + 1, NewY is Y - 2
    ; NewX is X + 1, NewY is Y + 2
    ; NewX is X - 2, NewY is Y - 1 
    ; NewX is X - 2, NewY is Y + 1 
    ; NewX is X + 2, NewY is Y - 1
    ; NewX is X + 2, NewY is Y + 1 ).

% check if it's a valid move
valid_move(X, Y) :- X &gt; 0, X =&lt; 8,
    				Y &gt; 0, Y =&lt; 8.

% check if next move is not visited before
possible_knight_moves(X, Y, Visits, NewX, NewY) :-
    knight_moves(X, Y, NewX, NewY),
	valid_move(NewX, NewY),
    not(member((NewX, NewY), Visits)).

% counts all possible moves
possible_moves_count(X, Y, Visits, Count) :-
    findall(_, possible_knight_moves(X, Y, Visits, _NewX, _NewY), Moves),
    length(Moves, Count).

% get all possible moves with their scores
getMovesAndScores(X, Y, Visits, Moves, Scores) :-
	findall((NewX, NewY), possible_knight_moves(X, Y, [(X, Y) | Visits], NewX, NewY), Moves),
    length(Moves,L),
    length(Scores,L),
    getScores(Moves,Visits,Scores).

% get the scores
getScores(Moves,Visits,Scores) :-
    length(Moves,L), L &gt; 0,
    Moves = [(X,Y)|T],
    possible_moves_count(X, Y, [(X, Y) | Visits], Score),
    getScores(T, Visits, RestScores),
    Scores = [Score|RestScores].
getScores(Moves,_,_) :- 
    length(Moves,L), L = 0.

% get next best move
getNextHeuristic(Moves,Scores,NewMoves,NewScores,NewX,NewY):-
    min_in_list(Scores,MinScore),
    corresponding(MinScore, (NewX,NewY), Scores, Moves),
    delete_one(MinScore,Scores,NewScores),
    delete_one((NewX,NewY),Moves,NewMoves).

knight(X, Y, Visits, Path) :-
    length(Visits, L),
    L = 63,
    NewVisits = [(X, Y) | Visits],
    reverse(NewVisits, Path).

knight(X, Y, Visits, Path) :-
    length(Visits, L),
    L &lt; 63,
    getMovesAndScores(X, Y, Visits, Moves, Scores),
    getNextHeuristic(Moves,Scores,NewMoves,NewScores,NewX,NewY),
    Moves = NewMoves,
    Scores = NewScores,
    NewVisits = [(X, Y) | Visits],
    knight(NewX, NewY, NewVisits, Path).

%% helping predicates
% get the smallest element in a list
smallest([A], A).
smallest([A, B|C], D) :- A &gt; B, smallest([B|C], D), !.
smallest([A, _|B], C) :- smallest([A|B], C).
% get the corresponding element in one list to another element in another list
corresponding(A, B, [A|_], [B|_]).
corresponding(A, B, [_|C], [_|D]) :-
    corresponding(A, B, C, D).
% get minimum element in list
min_in_list([Min],Min).
min_in_list([H,K|T],M) :-
    H =&lt; K,
    min_in_list([H|T],M).
min_in_list([H,K|T],M) :-
    H &gt; K,
    min_in_list([K|T],M).
% delete first occurence only from a list
delete_one(_, [], []).
delete_one(Term, [Term|Tail], Tail).
delete_one(Term, [Head|Tail], [Head|Result]) :-
  delete_one(Term, Tail, Result).
</div>

<div class="nb-cell query" name="q2">
knight(1, 1, [], Path).
</div>

</div>
